#!/usr/bin/env bash
# gwt - Git Worktree Tool (part of Grove)
# https://github.com/donkoko/grove

set -e

VERSION="0.0.1"

# Spinner helpers
SPINNER_PID=""
SPINNER_MSG=""
SPINNER_TMPFILE=""

cleanup_spinner() {
  if [[ -n "$SPINNER_PID" ]]; then
    kill "$SPINNER_PID" 2>/dev/null || true
    wait "$SPINNER_PID" 2>/dev/null || true
    SPINNER_PID=""
    printf "\r\033[K" >&2
  fi
  [[ -n "$SPINNER_TMPFILE" ]] && rm -f "$SPINNER_TMPFILE"
}
trap cleanup_spinner EXIT INT TERM

start_spinner() {
  SPINNER_MSG="$1"
  SPINNER_TMPFILE=$(mktemp)
  (
    local frames=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
    local i=0
    while true; do
      printf "\r${frames[$i]} %s" "$SPINNER_MSG" >&2
      i=$(( (i + 1) % ${#frames[@]} ))
      sleep 0.08
    done
  ) &
  SPINNER_PID=$!
}

stop_spinner() {
  local exit_code="${1:-0}"
  local success_msg="${2:-$SPINNER_MSG}"
  if [[ -n "$SPINNER_PID" ]]; then
    kill "$SPINNER_PID" 2>/dev/null || true
    wait "$SPINNER_PID" 2>/dev/null || true
    SPINNER_PID=""
  fi
  printf "\r\033[K" >&2
  if [[ "$exit_code" -eq 0 ]]; then
    echo -e "\033[32m✓\033[0m ${success_msg}" >&2
  else
    echo -e "\033[31m✗\033[0m ${SPINNER_MSG}" >&2
    if [[ -s "$SPINNER_TMPFILE" ]]; then
      sed 's/^/  /' "$SPINNER_TMPFILE" >&2
    fi
  fi
  rm -f "$SPINNER_TMPFILE"
  SPINNER_TMPFILE=""
}

# Configuration with defaults
GWT_DIR="${GWT_DIR:-.worktrees}"
GWT_ENV_FILES="${GWT_ENV_FILES:-.env .env.local}"
GWT_SKIP_INSTALL="${GWT_SKIP_INSTALL:-0}"
GWT_LINK_ENV="${GWT_LINK_ENV:-0}"
GWT_COPY_PATHS="${GWT_COPY_PATHS:-}"

show_help() {
  cat << EOF
gwt - Git Worktree Tool (part of Grove)

Usage:
  gwt <existing-branch> [-f folder]        Checkout an existing branch
  gwt -n <new-branch> [base] [-f folder]   Create a new branch (default base: main)
  gwt list                                 List all worktrees
  gwt remove <name> [--force]              Remove a worktree
  gwt update                               Update grove to latest version

Options:
  -n             Create a new branch instead of checking out existing
  -f <name>      Custom folder name (default: branch name without prefix)
  -l, --link     Symlink env files instead of copying
  -s, --skip     Skip dependency installation
  -h, --help     Show this help message
  -v, --version  Show version

Examples:
  gwt feature/auth                    # → .worktrees/auth
  gwt feature/auth -f login           # → .worktrees/login
  gwt -n feature/new-thing            # new branch from main
  gwt -n feature/new-thing dev        # new branch from dev
  gwt -n feature/new-thing -f cool    # custom folder name
  gwt feature/auth -s                 # skip npm install
  gwt list                            # list all worktrees
  gwt remove auth                     # remove .worktrees/auth
  gwt remove auth --force             # force remove if dirty
  gwt update                          # update grove to latest version

Configuration (environment variables):
  GWT_DIR          Worktrees directory name (default: .worktrees)
  GWT_ENV_FILES    Space-separated env files to copy (default: .env .env.local)
  GWT_COPY_PATHS   Space-separated files/folders to copy (e.g., .cert .config)
  GWT_SKIP_INSTALL Set to 1 to always skip dependency installation
  GWT_LINK_ENV     Set to 1 to symlink env files instead of copying

The worktree is created at <GWT_DIR>/<folder-name>
EOF
}

show_version() {
  echo "gwt version $VERSION"
}

cmd_list() {
  git worktree list
}

cmd_update() {
  start_spinner "Updating grove..."
  local rc=0
  curl -fsSL https://raw.githubusercontent.com/donkoko/grove/main/install.sh | bash > "$SPINNER_TMPFILE" 2>&1 || rc=$?
  stop_spinner "$rc" "Grove updated successfully"
  [[ "$rc" -ne 0 ]] && exit 1
}

select_worktree() {
  local -a items=("$@")
  local count=${#items[@]}
  local selected=0
  local hint="\033[2m↑/↓ navigate · enter select · esc/q cancel\033[0m"
  # Total drawn lines: count + 1 (blank line before hint) + 1 (hint)
  local total_lines=$((count + 2))

  # Hide cursor
  printf "\033[?25l" >&2
  trap 'printf "\033[?25h" >&2' RETURN

  _draw_list() {
    for i in "${!items[@]}"; do
      if [[ $i -eq $selected ]]; then
        printf "\033[36m❯ %s\033[0m\n" "${items[$i]}" >&2
      else
        printf "  %s\n" "${items[$i]}" >&2
      fi
    done
    printf "\n" >&2
    printf "${hint}\n" >&2
  }

  _draw_list

  while true; do
    IFS= read -rsn1 key
    if [[ "$key" == $'\x1b' ]]; then
      read -rsn1 -t 1 next 2>/dev/null || true
      if [[ -n "$next" ]]; then
        read -rsn1 -t 1 dir 2>/dev/null || true
        key+="${next}${dir}"
      fi
    fi

    case "$key" in
      $'\x1b[A'|k)
        ((selected > 0)) && ((selected--))
        ;;
      $'\x1b[B'|j)
        ((selected < count - 1)) && ((selected++))
        ;;
      "")
        break
        ;;
      q|$'\x1b')
        printf "\033[%dA\033[J" "$total_lines" >&2
        return 1
        ;;
    esac

    printf "\033[%dA\033[J" "$total_lines" >&2
    _draw_list
  done

  echo "${items[$selected]}"
}

cmd_remove() {
  local name="$1"
  local force="$2"

  if [[ -z "$name" ]]; then
    # Interactive selection if no name given
    if [[ ! -d "$GWT_DIR" ]]; then
      echo "No worktrees found." >&2
      exit 1
    fi

    local -a worktrees=()
    for dir in "$GWT_DIR"/*/; do
      [[ -d "$dir" ]] && worktrees+=("$(basename "$dir")")
    done

    if [[ ${#worktrees[@]} -eq 0 ]]; then
      echo "No worktrees found." >&2
      exit 1
    fi

    echo -e "\033[1mSelect a worktree to remove:\033[0m" >&2
    echo "" >&2
    name=$(select_worktree "${worktrees[@]}") || exit 0
  fi

  local worktree_path="${GWT_DIR}/${name}"

  if [[ ! -d "$worktree_path" ]]; then
    echo "Error: Worktree '${worktree_path}' does not exist."
    exit 1
  fi

  local rc=0
  start_spinner "Removing worktree..."
  if [[ "$force" == "--force" ]] || [[ "$force" == "-f" ]]; then
    git worktree remove --force "$worktree_path" > "$SPINNER_TMPFILE" 2>&1 || rc=$?
  else
    git worktree remove "$worktree_path" > "$SPINNER_TMPFILE" 2>&1 || rc=$?
  fi
  stop_spinner "$rc" "Removed worktree ${worktree_path}"
  [[ "$rc" -ne 0 ]] && exit 1
}

main() {
  # Handle subcommands
  case "${1:-}" in
    list)
      cmd_list
      exit 0
      ;;
    remove)
      shift
      cmd_remove "${1:-}" "${2:-}"
      exit 0
      ;;
    update)
      cmd_update
      exit 0
      ;;
  esac

  local new_branch=false
  local base_branch="main"
  local folder_name=""
  local branch=""
  local skip_install=false
  local link_env=false
  local positional=()

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -v|--version)
        show_version
        exit 0
        ;;
      -n)
        new_branch=true
        shift
        ;;
      -f)
        folder_name="$2"
        shift 2
        ;;
      -s|--skip)
        skip_install=true
        shift
        ;;
      -l|--link)
        link_env=true
        shift
        ;;
      -*)
        echo "Error: Unknown option $1"
        echo "Use --help for usage."
        exit 1
        ;;
      *)
        positional+=("$1")
        shift
        ;;
    esac
  done

  # Extract positional args (bash arrays are 0-indexed)
  branch="${positional[0]:-}"

  if [[ -z "$branch" ]]; then
    echo "Error: No branch specified. Use --help for usage."
    exit 1
  fi

  # Check if we're in a git repo
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "Error: Not in a git repository."
    exit 1
  fi

  # Check if we're in the repo root
  local repo_root
  repo_root=$(git rev-parse --show-toplevel)
  
  if [[ "$PWD" != "$repo_root" ]]; then
    echo "Error: Not in the root of the git repository."
    echo "Run this from: $repo_root"
    exit 1
  fi

  # Use custom folder name or derive from branch
  if [[ -z "$folder_name" ]]; then
    folder_name="${branch##*/}"
  fi

  if [[ "$new_branch" == true ]] && [[ -n "${positional[1]:-}" ]]; then
    base_branch="${positional[1]}"
  fi

  # Create worktrees directory if it doesn't exist
  mkdir -p "$GWT_DIR"

  # Add to .gitignore if not already there
  if [[ -f ".gitignore" ]]; then
    if ! grep -q "^${GWT_DIR}/$" .gitignore 2>/dev/null; then
      echo "${GWT_DIR}/" >> .gitignore
    fi
  else
    echo "${GWT_DIR}/" > .gitignore
  fi

  local worktree_path="${GWT_DIR}/${folder_name}"

  # Create the worktree
  local rc=0
  start_spinner "Creating worktree..."
  if [[ "$new_branch" == true ]]; then
    git worktree add -b "$branch" "${worktree_path}" "$base_branch" > "$SPINNER_TMPFILE" 2>&1 || rc=$?
  else
    git worktree add "${worktree_path}" "$branch" > "$SPINNER_TMPFILE" 2>&1 || rc=$?
  fi
  stop_spinner "$rc" "Created worktree"
  [[ "$rc" -ne 0 ]] && exit 1

  # Copy or symlink env files
  local has_env=false
  for env_file in $GWT_ENV_FILES; do
    [[ -f "${env_file}" ]] && has_env=true && break
  done

  if [[ "$has_env" == true ]]; then
    start_spinner "Copying env files..."
    for env_file in $GWT_ENV_FILES; do
      if [[ -f "${env_file}" ]]; then
        if [[ "$link_env" == true ]] || [[ "$GWT_LINK_ENV" == "1" ]]; then
          ln -sf "../../${env_file}" "${worktree_path}/${env_file}"
        else
          cp "${env_file}" "${worktree_path}/${env_file}"
        fi
      fi
    done
    local env_action="Copied"
    if [[ "$link_env" == true ]] || [[ "$GWT_LINK_ENV" == "1" ]]; then
      env_action="Linked"
    fi
    stop_spinner 0 "${env_action} env files"
  fi

  # Copy additional paths (files or directories)
  if [[ -n "$GWT_COPY_PATHS" ]]; then
    local has_paths=false
    for copy_path in $GWT_COPY_PATHS; do
      [[ -e "${copy_path}" ]] && has_paths=true && break
    done

    if [[ "$has_paths" == true ]]; then
      start_spinner "Copying additional paths..."
      for copy_path in $GWT_COPY_PATHS; do
        if [[ -e "${copy_path}" ]]; then
          cp -r "${copy_path}" "${worktree_path}/"
        fi
      done
      stop_spinner 0 "Copied additional paths"
    fi
  fi

  # Use nvm default if nvm is available (source it first if needed)
  if [[ -s "$HOME/.nvm/nvm.sh" ]]; then
    source "$HOME/.nvm/nvm.sh" 2>/dev/null
    nvm use default > /dev/null 2>&1 || true
  fi

  # Install dependencies unless skipped
  if [[ "$skip_install" != true ]] && [[ "$GWT_SKIP_INSTALL" != "1" ]]; then
    cd "$worktree_path"

    local pkg_manager=""
    if [[ -f "package-lock.json" ]]; then
      pkg_manager="npm"
    elif [[ -f "pnpm-lock.yaml" ]]; then
      pkg_manager="pnpm"
    elif [[ -f "yarn.lock" ]]; then
      pkg_manager="yarn"
    elif [[ -f "bun.lockb" ]]; then
      pkg_manager="bun"
    fi

    if [[ -n "$pkg_manager" ]]; then
      rc=0
      start_spinner "Installing dependencies..."
      $pkg_manager install > "$SPINNER_TMPFILE" 2>&1 || rc=$?
      stop_spinner "$rc" "Installed dependencies (${pkg_manager})"
      [[ "$rc" -ne 0 ]] && cd - > /dev/null && exit 1
    fi

    cd - > /dev/null
  fi

  echo "" >&2
  echo -e "\033[32m✓\033[0m Worktree ready at ${worktree_path}" >&2
  
  # Output path marker for shell integration to capture (hidden when running directly in a terminal)
  if [[ ! -t 1 ]]; then
    echo "GWT_PATH:${PWD}/${worktree_path}"
  fi
}

main "$@"
